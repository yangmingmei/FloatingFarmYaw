"""
Floating offshore wind farm yaw control via model-based deep reinforcement learning
(2025.6.10)

63-turbine with/without sensor noise

for evaluation

"""
import numpy as np
from floris import (FlorisModel,
                    ParFlorisModel,
                    TimeSeries, )
from mooring_matrix import moor_matrix
from py_wake.examples.data import example_data_path
from matplotlib import rcParams
import time
from utilities import set_grid_reposition
import matplotlib.pyplot as plt
import scipy

config = {
    "font.family": 'Times New Roman',
    "axes.unicode_minus": False,
    'xtick.direction': 'in',
    'ytick.direction': 'in'
}
rcParams.update(config)


class Fatigue_LUT:
    def __init__(self):
        data = np.load('./Fatigue_Load/Leq_turbulence.npz')
        self.Leq_RootMyb1_norm_ti = data['Leq_RootMyb1_norm_ti']
        self.Leq_TwrBsMyt_norm_ti = data['Leq_TwrBsMyt_norm_ti']
        self.ti = data['Ti'] / 100
        data = np.load('./Fatigue_Load/Leq_ws.npz')
        self.Leq_RootMyb1_norm_ws = data['Leq_RootMyb1_norm_ws']
        self.Leq_TwrBsMyt_norm_ws = data['Leq_TwrBsMyt_norm_ws']
        self.ws = data['Ws']
        data = np.load('./Fatigue_Load/Leq_yaw13.npz')
        self.Leq_RootMyb1_norm_yaw = data['Leq_RootMyb1_norm_yaw']
        self.Leq_TwrBsMyt_norm_yaw = data['Leq_TwrBsMyt_norm_yaw']
        self.yaw = data['yaw']

    def get_fatigue(self, windspeed, turbulence, yaw_angles):
        fatigue_RootMyb1 = np.interp(windspeed, self.ws, self.Leq_RootMyb1_norm_ws) * \
                           np.interp(turbulence, self.ti, self.Leq_RootMyb1_norm_ti) * \
                           np.interp(yaw_angles, self.yaw, self.Leq_RootMyb1_norm_yaw)
        fatigue_TwrBsMyt = np.interp(windspeed, self.ws, self.Leq_TwrBsMyt_norm_ws) * \
                           np.interp(turbulence, self.ti, self.Leq_TwrBsMyt_norm_ti) * \
                           np.interp(yaw_angles, self.yaw, self.Leq_TwrBsMyt_norm_yaw)

        fatigue = (fatigue_RootMyb1 * 0.5 + fatigue_TwrBsMyt * 0.5)

        return fatigue, fatigue_TwrBsMyt, fatigue_RootMyb1


class Environment:

    def __init__(self, evaluation, n_parallel, n_steps, n_days):
        """
         The 63-turbine floating wind farm environment for deep reinforcement learning training
        """
        # simulation setup
        self.fmodel = FlorisModel(r"inputs_floating/emgauss_floating.yaml")
        self.fmodel.set(turbine_type=['iea_15MW'])
        FlorisModel.assign_hub_height_to_ref_height(self.fmodel)

        self.iteration_num = 5

        # 定义坐标文件路径
        coordinates_file_path = "inputs_floating/63_turbine_coordinates.txt"

        # 初始化列表来存储坐标
        circle_positions = []

        # 读取文件内容
        with open(coordinates_file_path, "r") as file:
            for line in file:
                # 每行的格式是 "x, y"，我们需要提取这两个数值
                x, y = map(int, line.strip().split(","))
                circle_positions.append((x, y))  # 将坐标保存为 (x, y) 的元组

        pos = np.array(circle_positions)
        x = pos[:, 0] * 12
        y = -pos[:, 1] * 12

        self.x = x.flatten()
        self.y = y.flatten()

        # counterclockwise rotation
        phi = 30 * np.pi / 180
        self.x = (np.array(x) * np.cos(phi) - np.array(y) * np.sin(phi))
        self.y = (np.array(x) * np.sin(phi) + np.array(y) * np.cos(phi))

        # Environment properties
        self.j = 0  # index of steps
        self.n_turbines = len(self.x)  # number of turbines
        self.action_dim = self.n_turbines
        self.observation_dim = self.n_turbines * 3
        self.max_action = 1
        self.evaluation = evaluation  # when evaluation is true, using the same measurements

        # wind conditions
        self.days = n_days  # using a 10-day measurement in the environment
        self._max_episode_steps = n_steps  # steps in an episode
        self.n_parallel = n_parallel  # collecting samples in parallel
        self.wind_directions = []
        self.wind_speeds = []
        self.ti = []
        self.wind_series = []

        # turbine positions
        self.position = []
        self.x_tile = np.tile(self.x.reshape(-1, 1), self.n_parallel)
        self.x_tile = self.x_tile.T
        self.y_tile = np.tile(self.y.reshape(-1, 1), self.n_parallel)
        self.y_tile = self.y_tile.T

        # mooring system analysis with look-up tables generated by MoorPy
        self.moor_look_up_table = moor_matrix()
        self.moor_look_up_table.get_mooring_matrix(visualize=False)

        # Fatigue analysis with look-up tables generated by OpenFAST
        self.Fatigue_LUT = Fatigue_LUT()

        # # data collection
        # self.power_profile = []
        # self.tower_fatigue = []
        # self.blade_fatigue = []

    def reset(self, visualize, day_start):
        # simulation setup
        self.j = 0

        # Real offshore measurements in the North Sea, 365 days in total with 10 min interval.
        d = np.load(example_data_path + "/time_series.npz")
        if self.evaluation:
            day_start = day_start
        else:
            day_start = np.random.randint(0, high=300, size=None, dtype='l')
        print(f'starting from {day_start} days')
        wd, ws, ws_std = [d[k][int(6 * 24 * day_start):6 * 24 * int(self.days + day_start)] for k in
                          ['wd', 'ws', 'ws_std']]

        ws = ws + 1.5
        ti = np.minimum(ws_std / ws, .5)

        # 原始 ws 对应的 x 轴索引
        x_old = np.linspace(0, 1, len(ws))  # 假设原始 ws 在 [0,1] 区间上均匀分布

        # self.n_parallel = 1024
        # 新的 x 轴坐标，用于插值，长度为
        x_new = np.linspace(0, 1, self.n_parallel + self._max_episode_steps + 1)

        # # 创建插值函数（线性插值，也可以改为 'cubic' 或 'quadratic'）
        # ws_interp = np.interp(x_new, x_old, ws)

        self.ti = np.interp(x_new, x_old, ti)

        self.wind_directions = np.interp(x_new, x_old, wd)
        self.wind_speeds = np.interp(x_new, x_old, ws)
        self.wind_series = TimeSeries(self.wind_directions[self.j:self.n_parallel + self.j],
                                      self.wind_speeds[self.j:self.n_parallel + self.j],
                                      self.ti[self.j:self.n_parallel + self.j])

        # run the first simulation until the convergence of wind turbine position
        self.fmodel.set(
            wind_data=self.wind_series,
        )
        yaw_angles_tile = np.zeros_like(self.x_tile)

        self.position = [np.zeros_like(self.x_tile) for _ in range(4)]

        for i in range(self.iteration_num):
            self.fmodel.set(layout_x=self.x,
                            layout_y=self.y,
                            yaw_angles=yaw_angles_tile + self.position[3] * 180 / np.pi)
            set_grid_reposition(self.fmodel.core.grid, self.x_tile + self.position[0], self.y_tile + self.position[1])
            self.fmodel.run()

            wind_speeds = self.fmodel.turbine_average_velocities
            thrust_coefficients = self.fmodel.get_turbine_thrust_coefficients()
            thrusts = 0.5 * 1.225 * (120 ** 2) * np.pi * thrust_coefficients * wind_speeds ** 2

            theta = (-self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)
                     + 270 + yaw_angles_tile) * np.pi / 180 + self.position[3]
            self.position = self.moor_look_up_table.get_position(
                (thrusts * np.cos(theta), thrusts * np.sin(theta)))

        Yaw_angles_tile_rotate = yaw_angles_tile + self.position[3] * 180 / np.pi

        # get observation
        wind_directions = self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1) * np.ones_like(
            self.x_tile)

        # noise = np.random.normal(loc=0, scale=0.03, size=self.x_tile.shape)

        obs = np.concatenate([wind_speeds / 20 + np.random.normal(loc=0, scale=0.03, size=self.x_tile.shape),
                              (Yaw_angles_tile_rotate) / 90,
                              wind_directions / 360 + np.random.normal(loc=0, scale=0.03, size=self.x_tile.shape)],
                             1)

        obs = np.concatenate([wind_speeds / 20,
                              (Yaw_angles_tile_rotate) / 90,
                              wind_directions / 360],
                             1)

        return obs

    def step(self, actions):

        self.j = self.j + 1

        self.wind_series = TimeSeries(self.wind_directions[self.j:self.n_parallel + self.j],
                                      self.wind_speeds[self.j:self.n_parallel + self.j],
                                      self.ti[self.j:self.n_parallel + self.j])

        self.fmodel.set(
            wind_data=self.wind_series,
        )

        yaw_angles_tile = actions * 360 - self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)

        yaw_angles_tile[yaw_angles_tile > 80] = 80
        yaw_angles_tile[yaw_angles_tile < -80] = -80

        for i in range(self.iteration_num):
            self.fmodel.set(
                yaw_angles=yaw_angles_tile + self.position[3] * 180 / np.pi)
            set_grid_reposition(self.fmodel.core.grid, self.x_tile + self.position[0], self.y_tile + self.position[1])
            self.fmodel.run()

            wind_speeds = self.fmodel.turbine_average_velocities
            thrust_coefficients = self.fmodel.get_turbine_thrust_coefficients()
            thrusts = 0.5 * 1.225 * (120 ** 2) * np.pi * thrust_coefficients * wind_speeds ** 2

            theta = (-self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)
                     + 270 + yaw_angles_tile) * np.pi / 180 + self.position[3]
            self.position = self.moor_look_up_table.get_position(
                (thrusts * np.cos(theta), thrusts * np.sin(theta)))

        Yaw_angles_tile_rotate = yaw_angles_tile + self.position[3] * 180 / np.pi
        # get observation
        wind_directions = self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1) * np.ones_like(
            self.x_tile)
        next_obs = np.concatenate([wind_speeds / 20 + np.random.normal(loc=0, scale=0.03, size=self.x_tile.shape),
                                   (Yaw_angles_tile_rotate) / 90,
                                   wind_directions / 360 + np.random.normal(loc=0, scale=0.03, size=self.x_tile.shape)],
                                  1)
        next_obs = np.concatenate([wind_speeds / 20 ,
                                   (Yaw_angles_tile_rotate) / 90,
                                   wind_directions / 360],
                                  1)

        power = self.fmodel.get_turbine_powers() / 15e6

        # print(yaw_angles_tile)

        fatigue, tower_fatigue, blade_fatigue = self.Fatigue_LUT.get_fatigue(wind_speeds,
                                                                             0.10 * np.ones_like(wind_speeds),
                                                                             Yaw_angles_tile_rotate)
        #
        # reward = (np.sum(power ** 2, 1) * 1) - np.sum(fatigue ** 2, 1)
        # reward = np.sum(power ** 2, 1) - np.sum((Yaw_angles_tile_rotate/200) ** 2, 1)

        reward = np.sum(power ** 2, 1) - np.sum((actions - wind_directions / 360) ** 2, 1)
        # print(f'power:{np.sum(power ** 2, 1) * 1}\n'
        #       f'fatigue:{np.sum(fatigue ** 2, 1) * 0.09}')

        # print(f'ratio{np.sum(power ** 2, 1) / np.sum(fatigue ** 2, 1)}')

        info = [power, fatigue, tower_fatigue, blade_fatigue]

        done = 0

        if self.j == self._max_episode_steps:
            done = 1

        return [next_obs, reward, done, info]


if __name__ == "__main__":

    # evaluation
    env = Environment(evaluation=True, n_parallel=1, n_steps=144, n_days=1)
    observation = env.reset(visualize=False, day_start=21.5)

    # training
    # env = Environment(evaluation=True, n_parallel=1024, n_steps=40, n_days=1.25)
    # env = Environment(evaluation=True, n_parallel=248, n_steps=40, n_days=1.25)
    # observation = env.reset(visualize=False, day_start=21.25)

    print(f'Parallel: {env.n_parallel}  \nTotal steps:{env._max_episode_steps}')
    start_time = time.time()

    # observation = env.reset(visualize=False, day_start=21.5)

    axes = plt.subplots(3, 1, sharex=True, figsize=(8, 5))[1]
    for ax, (v, l) in zip(axes,
                          [(env.wind_directions, 'Wind direction [deg]'),
                           (env.wind_speeds, 'Wind speed [m/s]'),
                           (env.ti, 'Turbulence intensity')]):
        ax.plot(range(len(v)), v)
        ax.set_ylabel(l)
    _ = ax.set_xlabel('Time [day]')

    plt.show()

    epi_reward = 0
    WF_energy = []
    WF_fatigue = []
    WF_tower_fatigue = []
    WF_blade_fatigue = []
    WF_action = []

    for j in range(env._max_episode_steps):
        actions = np.random.uniform(-30, 30, [env.n_parallel, env.n_turbines]) * 0 / 360 \
                  + env.wind_directions[j + 1: env.n_parallel + j + 1].reshape(-1, 1) / 360 \
                  + 60 / 360
        # print(actions.shape[0])
        _, Reward, _, info = env.step(actions)
        WFpower = info[0]
        Fatigue = info[1]
        Tower_fatigue = info[2]
        Blade_fatigue = info[3]

        epi_reward = epi_reward + Reward
        WF_energy.append(np.sum(WFpower, 1) / 6)
        WF_fatigue.append(np.sum(Fatigue, 1))
        WF_tower_fatigue.append(np.sum(Tower_fatigue, 1))
        WF_blade_fatigue.append(np.sum(Blade_fatigue, 1))
        WF_action.append(actions)

        print(f'Time Step: {env.j}')

    end_time = time.time()

    print(f'running time:{end_time - start_time}')

    print(f'episode reward: {epi_reward.mean()}')
    print(f'episode energy: {np.array(WF_energy).mean()}MWh')
    print(f'episode fatigue: {np.array(WF_fatigue).mean()} p.u.')
    print(f'episode tower fatigue: {np.array(WF_tower_fatigue).mean()} p.u.')
    print(f'episode blade fatigue: {np.array(WF_blade_fatigue).mean()} p.u.')

    scipy.io.savemat('Performance_63turbine/ppo.mat',
                     {'Power': np.array(WF_energy), 'WFenergy': np.array(WF_energy).mean(), 'WD': env.wind_directions,
                      'WS': env.wind_speeds, 'TI': env.ti, 'Action': np.array(WF_action),
                      'Fatigue': np.array(WF_fatigue), 'Tower_fatigue': np.array(WF_tower_fatigue),
                      'Blade_fatigue': np.array(WF_blade_fatigue)})
