
"""
Improving Floating Offshore Wind Farm Flow Control with Scalable Model-based Deep Reinforcement Learning
(2025.5.16)

This is a floating offshore wind farm simulator formulated as a parallel DRL environment.

state = [wind directions, wind speeds, yaw angles(in the farm coordinate)] NÃ—3
Action = nacelle yaw angles(farm coordinate)
reward = sum[(P/P_0)^2] + sum[(Yaw/360)^2]
"""

import numpy as np
from floris import (FlorisModel,
                    TimeSeries, )
from mooring_matrix import moor_matrix
from py_wake.examples.data import example_data_path
from matplotlib import rcParams
import time
from utilities import set_grid_reposition
import matplotlib.pyplot as plt

config = {
    "font.family": 'Times New Roman',
    "axes.unicode_minus": False,
    'xtick.direction': 'in',
    'ytick.direction': 'in'
}
rcParams.update(config)


class Environment:

    def __init__(self, evaluation):
        """
         The 29-turbine floating wind farm environment for deep reinforcement learning training
        """
        # simulation setup
        self.fmodel = FlorisModel(r"inputs_floating/emgauss_floating.yaml")
        self.fmodel.set(turbine_type=['iea_15MW'])
        FlorisModel.assign_hub_height_to_ref_height(self.fmodel)

        self.iteration_num = 5

        x = [4193.62372567192,
             4586.23169601483, 4207.909022918064, 3822.671339711839,
             3439.185657229091, 3061.6924881018426, 2676.475469958829,
             3868.77479147359, 3479.8198869796765, 3094.605331044565,
             2707.6286696999778, 2315.2792370310417, 1931.7403314094568, 1544.76367006487,
             3525.49397590361, 3133.125437405249, 2740.608840334446, 2350.7386279644306,
             1957.3645790887745, 1564.1385887855513, 1172.5534728058212, 786.11306765524,
             2804.60426320667, 2408.246264201987, 2009.1108340703724, 1611.699404782204,
             1214.816882330398, 819.5326086704703, 422.23540315107
             ]

        y = [1057.3791821561301,
             1672.9962825278799, 2045.790730432492, 2425.399143133105,
             2803.2811561519584, 3175.258221181207, 3554.846270786033,
             1349.4126394052, 1718.7113456882025, 2084.458725409041,
             2451.879160901989, 2824.400849718425, 3188.557259674342, 3555.9776951672898,
             650.60966542751, 1010.7905655699709, 1371.1073784186349, 1728.9949006129034,
             2090.098824895329, 2451.066836471561, 2810.5285815333623, 3165.26765799256,
             327.02602230483, 677.2402547409571, 1029.9085713956556, 1381.0535943774057,
             1731.7312855475302, 2080.9967951159333, 2432.04089219331
             ]

        # rotating the wind farm for visualization
        phi = - 27 * np.pi / 180
        self.x = (np.array(x) * np.cos(phi) - np.array(y) * np.sin(phi)) * 240 / 126 - 2200
        self.y = (np.array(x) * np.sin(phi) + np.array(y) * np.cos(phi)) * 240 / 126

        # Environment properties
        self.j = 0  # index of steps
        self.n_turbines = len(self.x)  # number of turbines
        self.action_dim = self.n_turbines
        self.observation_dim = self.n_turbines * 3
        self.max_action = 1
        self.evaluation = evaluation  # when evaluation is true, using the same measurements

        # wind conditions
        self.days = 2  # using a 10-day measurement in the environment
        self._max_episode_steps = 50  # steps in an episode
        self.n_parallel = 144 * self.days - self._max_episode_steps  # collecting samples in parallel
        self.wind_directions = np.zeros([144 * self.days, ])
        self.wind_speeds = np.zeros([144 * self.days, ])
        self.ti = np.zeros([144 * self.days, ])
        self.wind_series = TimeSeries(self.wind_directions[self.j:self.n_parallel + self.j],
                                      self.wind_speeds[self.j:self.n_parallel + self.j],
                                      self.ti[self.j:self.n_parallel + self.j])

        # turbine positions
        self.position = []
        self.x_tile = np.tile(self.x.reshape(-1, 1), self.n_parallel)
        self.x_tile = self.x_tile.T
        self.y_tile = np.tile(self.y.reshape(-1, 1), self.n_parallel)
        self.y_tile = self.y_tile.T

        # mooring system analysis with look-up tables generated by MoorPy
        self.moor_look_up_table = moor_matrix()
        self.moor_look_up_table.get_mooring_matrix(visualize=False)

    def reset(self, visualize):
        # simulation setup
        self.j = 0

        # Real offshore measurements in the North Sea, 365 days in total with 10 min interval.
        d = np.load(example_data_path + "/time_series.npz")
        if self.evaluation:
            day_start = 0
        else:
            day_start = np.random.randint(0, high=300, size=None, dtype='l')
        print(f'starting from {day_start} days')
        wd, ws, ws_std = [d[k][6 * 24 * day_start:6 * 24 * (self.days + day_start)] for k in
                          ['wd', 'ws', 'ws_std']]
        self.ti = np.minimum(ws_std / ws, .5)

        self.wind_directions = wd + 20
        self.wind_speeds = ws + 3.5
        self.wind_series = TimeSeries(self.wind_directions[self.j:self.n_parallel + self.j],
                                      self.wind_speeds[self.j:self.n_parallel + self.j],
                                      self.ti[self.j:self.n_parallel + self.j])

        # run the first simulation until the convergence of wind turbine position
        self.fmodel.set(
            wind_data=self.wind_series,
        )
        yaw_angles_tile = np.zeros_like(self.x_tile)

        self.position = [np.zeros_like(self.x_tile) for _ in range(4)]

        for i in range(self.iteration_num):
            self.fmodel.set(layout_x=self.x,
                            layout_y=self.y,
                            yaw_angles=yaw_angles_tile + self.position[3] * 180 / np.pi)
            set_grid_reposition(self.fmodel.core.grid, self.x_tile + self.position[0], self.y_tile + self.position[1])
            self.fmodel.run()

            wind_speeds = self.fmodel.turbine_average_velocities
            thrust_coefficients = self.fmodel.get_turbine_thrust_coefficients()
            thrusts = 0.5 * 1.225 * (120 ** 2) * np.pi * thrust_coefficients * wind_speeds ** 2

            theta = (-self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)
                     + 270 + yaw_angles_tile) * np.pi / 180 + self.position[3]
            self.position = self.moor_look_up_table.get_position(
                (thrusts * np.cos(theta), thrusts * np.sin(theta)))

        Yaw_angles_tile_rotate = yaw_angles_tile + self.position[3] * 180 / np.pi
        # get observation
        wind_directions = self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1) * np.ones_like(
            self.x_tile)
        obs = np.concatenate([wind_speeds / 20,
                              (Yaw_angles_tile_rotate) / 90,
                              wind_directions / 360], 1)

        return obs

    def step(self, actions):

        self.j = self.j + 1

        self.wind_series = TimeSeries(self.wind_directions[self.j:self.n_parallel + self.j],
                                      self.wind_speeds[self.j:self.n_parallel + self.j],
                                      self.ti[self.j:self.n_parallel + self.j])

        self.fmodel.set(
            wind_data=self.wind_series,
        )

        yaw_angles_tile = actions * 360 - self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)

        yaw_angles_tile[yaw_angles_tile > 70] = 70
        yaw_angles_tile[yaw_angles_tile < -70] = -70

        for i in range(self.iteration_num):
            self.fmodel.set(
                            yaw_angles=yaw_angles_tile + self.position[3] * 180 / np.pi)
            set_grid_reposition(self.fmodel.core.grid, self.x_tile + self.position[0], self.y_tile + self.position[1])
            self.fmodel.run()

            wind_speeds = self.fmodel.turbine_average_velocities
            thrust_coefficients = self.fmodel.get_turbine_thrust_coefficients()
            thrusts = 0.5 * 1.225 * (120 ** 2) * np.pi * thrust_coefficients * wind_speeds ** 2

            theta = (-self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1)
                     + 270 + yaw_angles_tile) * np.pi / 180 + self.position[3]
            self.position = self.moor_look_up_table.get_position(
                (thrusts * np.cos(theta), thrusts * np.sin(theta)))

        Yaw_angles_tile_rotate = yaw_angles_tile + self.position[3] * 180 / np.pi

        # get observation
        wind_directions = self.wind_directions[self.j:self.n_parallel + self.j].reshape(-1, 1) * np.ones_like(
            self.x_tile)
        next_obs = np.concatenate([wind_speeds / 20,
                                   (Yaw_angles_tile_rotate) / 90,
                                   wind_directions / 360], 1)

        power = self.fmodel.get_turbine_powers() / 15e6
        reward = np.sum(power ** 2, 1) - np.sum((actions - wind_directions / 360) ** 2, 1)

        info = power
        done = 0

        if self.j == self._max_episode_steps - 1:
            done = 1

        return [next_obs, reward, done, info]


if __name__ == "__main__":

    env = Environment(evaluation=True)
    print(f'Parallel: {env.n_parallel}')
    start_time = time.time()
    observation = env.reset(visualize=False)

    axes = plt.subplots(3, 1, sharex=True, figsize=(16, 10))[1]
    for ax, (v, l) in zip(axes,
                          [(env.wind_directions, 'Wind direction [deg]'),
                           (env.wind_speeds, 'Wind speed [m/s]'),
                           (env.ti, 'Turbulence intensity')]):
        ax.plot(range(len(v)), v)
        ax.set_ylabel(l)
    _ = ax.set_xlabel('Time [day]')

    plt.show()

    epi_reward = 0
    WFenergy = 0

    for j in range(env._max_episode_steps):
        actions = np.random.uniform(-30, 30, [env.n_parallel, env.n_turbines]) * 0/360  \
                  + env.wind_directions[j+1: env.n_parallel + j+1].reshape(-1, 1) / 360 + 0/360
        # print(actions.shape[0])
        _, Reward, _, WFpower = env.step(actions)
        epi_reward = epi_reward + Reward
        WFenergy = WFenergy + np.sum(WFpower, 1) / 6
        print(f'Time Step: {env.j}')

    end_time = time.time()

    print(f'running time:{end_time - start_time}')

    print(f'episode reward: {epi_reward.mean()}')
    print(f'episode energy: {WFenergy.mean()}MWh')
